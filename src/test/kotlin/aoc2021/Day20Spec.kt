package aoc2021

import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe

class Day20Spec : FunSpec({
    val example = """
        ..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#

        #..#.
        #....
        ##..#
        ..#..
        ..###
    """.trimIndent().lines()

    test("parse map instructions") {
        val map = TrenchMap.parse(example)
        map.instructions.shouldBe(example[0])
        map.topLeft.shouldBe(Pair(0, 0))
        map.bottomRight.shouldBe(Pair(4, 4))
    }

    test("accessing coordinates") {
        val map = TrenchMap.parse(example)
        map[0, 0].shouldBe(true)
        map[0, 1].shouldBe(false)
        map[2, 4].shouldBe(true)
        map[-100, 1000].shouldBe(false)
    }

    test("instruction index") {
        val map = TrenchMap.parse(example)
        map.instructionIndex(3, 2).shouldBe(275)
        map.instructionIndex(0, 0).shouldBe(18)
    }

    test("evolve") {
        val map = TrenchMap.parse(example).evolve(1)
        map.topLeft.shouldBe(Pair(-1, -1))
        map.bottomRight.shouldBe(Pair(5, 5))
        map.toString().shouldBe("""
            ..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#
            
            .##.##.
            #..#.#.
            ##.#..#
            ####..#
            .#..##.
            ..##..#
            ...#.#.
        """.trimIndent())

        println(map.evolve(1).toString())
    }

    test("handle infinity :-)") {
        val infinite = """
        #.#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##..####..#...#.#.#...##..#.#..###..#####........#..####......#...

        .
        """.trimIndent().lines()
        TrenchMap.parse(infinite).evolve()[-3,-3].shouldBe(true)
        TrenchMap.parse(infinite).evolve(2)[-3,-3].shouldBe(false)
    }

    test("part 1") {
        TrenchMap.parse(example).evolve(2).points.size.shouldBe(35)
    }
})